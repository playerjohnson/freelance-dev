<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
        <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure DevOps CI/CD Pipeline Setup Guide | YAML Pipelines Tutorial</title>
    <meta name="description" content="How to set up Azure DevOps CI/CD pipelines from scratch. YAML pipeline configuration, build automation, automated testing, and deployment to Azure App Service.">
    <meta property="og:title" content="Azure DevOps CI/CD Pipeline Setup Guide | YAML Pipelines Tutorial">
    <meta property="og:description" content="How to set up Azure DevOps CI/CD pipelines from scratch. YAML pipeline configuration, build automation, automated testing, and deployment to Azure App Service.">
    <meta property="og:url" content="https://playerjohnson.github.io/freelance-dev/blog/azure-devops-pipelines-from-scratch.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Anthony D Johnson | Freelance Developer">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Azure DevOps CI/CD Pipeline Setup Guide | YAML Pipelines Tutorial">
    <meta name="twitter:description" content="How to set up Azure DevOps CI/CD pipelines from scratch. YAML pipeline configuration, build automation, automated testing, and deployment to Azure App Service.">
    <link rel="canonical" href="https://playerjohnson.github.io/freelance-dev/blog/azure-devops-pipelines-from-scratch.html">
    <link rel="stylesheet" href="../css/style.css">
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "Azure DevOps CI/CD Pipeline Setup Guide | YAML Pipelines Tutorial",
        "description": "How to set up Azure DevOps CI/CD pipelines from scratch. YAML pipeline configuration, build automation, automated testing, and deployment to Azure App Service.",
        "author": {
            "@type": "Person",
            "name": "Anthony D Johnson",
            "url": "https://playerjohnson.github.io/freelance-dev/"
        },
        "publisher": {
            "@type": "Person",
            "name": "Anthony D Johnson"
        },
        "url": "https://playerjohnson.github.io/freelance-dev/blog/azure-devops-pipelines-from-scratch.html",
        "datePublished": "2026-02-01",
        "dateModified": "2026-02-18"
    }
    </script>
</head>
<body>
<!-- GTM noscript --><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54K98MWX" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<a href="#main-content" class="skip-link" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;z-index:100000;padding:8px 16px;background:#f59e0b;color:#0a0e1a;font-weight:600;font-size:14px;text-decoration:none;font-family:-apple-system,system-ui,sans-serif;" onfocus="this.style.cssText='position:fixed;left:50%;top:8px;transform:translateX(-50%);width:auto;height:auto;overflow:visible;z-index:100000;padding:8px 16px;background:#f59e0b;color:#0a0e1a;font-weight:600;font-size:14px;text-decoration:none;border-radius:4px;font-family:-apple-system,system-ui,sans-serif;'" onblur="this.style.cssText='position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;'">Skip to content</a>

<header>
<nav role="navigation" aria-label="Main" class="nav">
    <div class="container">
        <a href="../" class="nav-logo">anthony<span>.</span>dev</a>
        <button class="nav-toggle" aria-label="Menu">☰</button>
        <ul class="nav-links">
            <li><a href="../index.html#services">Services</a></li>
            <li><a href="../index.html#stack">Stack</a></li>
            <li><a href="../index.html#about">About</a></li>
            <li><a href="../case-studies.html">Case Studies</a></li>
            <li><a href="../blog.html">Blog</a></li>
            <li><a href="../contact.html" class="nav-cta">Get in Touch</a></li>
        </ul>
    </div>
</nav>
</header>
<main id="main-content">
    <section class="article-hero">
    <div class="container">
        <p class="breadcrumb"><a href="../">Home</a> / <a href="../blog.html">Blog</a> / Setting Up Azure DevOps Pipelines from Scratch</p>
        <div class="section-label">DevOps</div>
        <h1>Setting Up Azure DevOps Pipelines from Scratch</h1>
    </div>
</section>

<article>
<div class="article-content fade-up">
<p>If your team is still building and deploying manually, you're wasting hours every week and introducing risk with every release. Here's how to set up Azure DevOps pipelines that automate the entire process, from commit to production.</p>

    <h2>Why YAML Pipelines?</h2>
    <p>Azure DevOps supports both the classic GUI editor and YAML pipelines. Use YAML. It lives in your repository alongside your code, so it's version controlled, reviewable in pull requests, and portable. When someone asks "what does the pipeline do?" the answer is in the repo, not locked inside a GUI that requires Azure DevOps admin access to view.</p>
    <p>The classic editor has its uses for learning and experimentation, but YAML is the standard for production pipelines. It supports everything the classic editor does, plus templating, conditional logic, and reusable pipeline components that make managing multiple projects significantly easier. If you have 10 .NET projects, you can define a shared pipeline template once and reference it from each project rather than maintaining 10 separate classic pipelines.</p>
    <p>YAML pipelines also integrate naturally with your branching strategy. You can define different pipeline behaviour for different branches — running full test suites on pull requests, deploying to staging on merges to develop, and deploying to production on merges to main. All of this is defined declaratively in the YAML file, visible to everyone on the team.</p>

    <h2>Build Pipeline Basics</h2>
    <p>A basic .NET build pipeline does four things: restore NuGet packages, build the solution, run tests, and publish the output as an artifact. In YAML, this takes about 30 lines. Trigger it on every push to your main branch and on pull requests so that every code change is validated automatically.</p>
    <p>Key tip: use <code>dotnet test --logger trx</code> to generate test results that Azure DevOps can display natively in the pipeline summary. Add code coverage with <code>coverlet</code> and publish the results — your team will actually look at coverage when it's visible in every PR rather than buried in a separate tool.</p>
    <p>For the build task itself, I recommend using <code>dotnet publish</code> rather than <code>dotnet build</code> for the artifact that gets deployed. The publish output includes everything needed to run the application, resolves runtime dependencies, and produces a deployment-ready package. This ensures that what you test is exactly what gets deployed — no discrepancies between build output and deployment package.</p>
    <p>Set the build to fail on warnings, not just errors. This catches potential issues early and prevents the slow accumulation of warnings that teams learn to ignore. If a warning is genuinely irrelevant, suppress it explicitly in the code with a comment explaining why, rather than training the team to ignore yellow in the pipeline output.</p>

    <h2>Release Pipeline: Multi-Stage Deployment</h2>
    <p>For deployment, I use multi-stage YAML pipelines. Stage 1 builds and tests. Stage 2 deploys to staging with automatic approval. Stage 3 deploys to production with a manual approval gate. Each stage references the artifact from Stage 1, ensuring you deploy exactly what you tested.</p>
    <p>The manual approval gate for production is important even if you trust your tests. It gives the team a chance to verify the staging deployment, run any manual checks they want, and confirm that the timing is right for a production release. For government teams, it also provides an audit trail showing who approved each production deployment and when — useful for change management processes and incident investigations.</p>
    <p>For Azure App Service deployments, I strongly recommend using deployment slots. Deploy to a staging slot first, verify the deployment, then swap the staging and production slots. The swap is near-instantaneous and, crucially, reversible — if the production deployment has issues, you can swap back to the previous version in seconds. This is dramatically safer than deploying directly to production.</p>
    <p>If your application uses a database, include database migration as a pipeline step. Entity Framework Core migrations can run as part of the deployment — apply pending migrations to the staging database, verify the application works, then apply the same migrations to production before the slot swap. This ensures database changes and code changes are always in sync.</p>

    <h2>Infrastructure as Code</h2>
    <p>Don't create Azure resources manually through the portal. Use Terraform or Bicep in your pipeline to create and update infrastructure. This means your staging and production environments are guaranteed identical (eliminating the "works in staging, breaks in production" problem), new environments can be spun up in minutes for testing or disaster recovery, infrastructure changes go through the same code review process as application changes, and your entire environment is documented in code rather than in someone's memory.</p>
    <p>I typically use Terraform for multi-cloud or complex infrastructure and Bicep for Azure-only deployments. Bicep has the advantage of native Azure integration and doesn't require state management, but Terraform's provider ecosystem and mature state management make it the better choice for anything beyond simple Azure resources.</p>
    <p>Store your infrastructure code in the same repository as your application code. Run <code>terraform plan</code> or the Bicep what-if command on pull requests so the team can review infrastructure changes before they're applied, just like they review code changes.</p>

    <h2>Branch Policies and Quality Gates</h2>
    <p>Once your build pipeline is reliable, enforce it. Configure branch policies on your main branch that require a successful build before merging, require at least one code reviewer to approve the pull request, require all PR comments to be resolved, and check for linked work items if you're tracking requirements in Azure DevOps.</p>
    <p>These policies prevent the most common sources of production issues: untested code, unreviewed code, and code that doesn't address the intended requirement. They add a small amount of friction to the development process, but the reduction in production incidents more than compensates.</p>
    <p>For code quality, add SonarQube or SonarCloud as a pipeline step. Configure quality gates that fail the build if code coverage drops below a threshold, if new code smells are introduced, or if security vulnerabilities are detected. This catches quality issues at the PR stage rather than after they've been merged and deployed.</p>

    <h2>Essential Additions</h2>
    <p>Once the basics are working reliably, add these in order of priority. Slack or Teams notifications for build failures so the team knows immediately when something breaks. Dependabot or Renovate for automated dependency updates, creating pull requests when new package versions are available. Scheduled nightly builds that run your full test suite including any slow integration tests you don't run on every commit. Container image scanning if you're deploying to Docker or Kubernetes. And licence scanning to ensure your dependencies don't introduce compliance issues.</p>
    <p>Notifications deserve special attention. The default Azure DevOps notifications are noisy and most teams learn to ignore them. Configure a dedicated Teams or Slack channel that only receives notifications for build failures and deployment completions. Keep the signal-to-noise ratio high so the team pays attention when a notification arrives.</p>

    <h2>Pipeline Performance</h2>
    <p>Slow pipelines kill developer productivity and encourage people to skip the process. A build pipeline for a typical .NET solution should complete in under 5 minutes. If yours takes longer, look for these common causes: NuGet package restore downloading the same packages every time (configure a package cache), test projects being built in Debug mode (build in Release for deployment), unnecessary clean builds when incremental builds would suffice, and Docker image builds pulling base images from Docker Hub on every run instead of caching them in Azure Container Registry.</p>
    <p>For test execution, run unit tests on every commit but run slower integration tests only on pull requests or nightly. This keeps the feedback loop fast for developers while still catching integration issues before they reach production.</p>

    <h2>Getting Started</h2>
    <p>If this feels overwhelming, start simple. Get a build pipeline running that restores, builds, and tests on every push. That alone catches most bugs before they reach production. Add deployment automation next. Then infrastructure as code. Then quality gates. Each step delivers value independently — the perfect pipeline is the enemy of the good pipeline.</p>
    <p>If you want hands-on help setting up Azure DevOps pipelines for your team, I offer a <a href="../services/devops-pipelines.html">dedicated DevOps and CI/CD service</a>. A basic pipeline setup typically takes one to two weeks and transforms how your team ships software. <a href="../contact.html">Get in touch</a> if you'd like to discuss your setup.</p>
</article>
</div>

<section>
    <div class="cta-section fade-up">
        <h2>Need Help With This?</h2>
        <p>I offer consulting and hands-on development for .NET, Azure, and DevOps projects. Let's talk about how I can help.</p>
        <a href="../contact.html" class="btn btn-primary">Get in Touch →</a>
    </div>
</section>

</main>

<footer role="contentinfo" class="footer">
    <div class="container">
        <div class="footer-bottom">
            <span>&copy; 2026 Anthony D Johnson. All rights reserved. <a href="../privacy.html" style="color:#94a3b8;text-decoration:underline;">Privacy</a> &middot; <a href="../terms.html" style="color:#94a3b8;text-decoration:underline;">Terms</a></span>
            <span>Peterborough, UK &middot; Remote Worldwide</span>
        </div>
    </div>
</footer>

<script src="../js/main.js"></script>
<script src="../cookie-consent.js"></script>
</body>
</html>